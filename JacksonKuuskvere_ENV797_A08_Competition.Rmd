---
title: "TSA Competition"
author: "Aditi Jackson and Cara Kuuskvere"
date: "2024-03-28"
output: pdf_document
---

```{r setup and packages}
library(lubridate)
library(ggplot2)
library(forecast)
library(Kendall)
library(tseries)
library(outliers)
library(tidyverse)
library(smooth)
library(dplyr)
library(readr)
library(readxl)
library(zoo)

```

## Data

```{r data, echo=FALSE}

# loading data
load_RAW <- read_excel("./Data/load.xlsx",col_names=TRUE,na="NA")
humidity_RAW <- read_excel("./Data/relative_humidity.xlsx",col_names=TRUE)
temperature_RAW <- read_excel("./Data/temperature.xlsx",col_names=TRUE)

# cleaning data in pipe
load_clean <- load_RAW %>%
  mutate(date = ymd(date)) %>%  ## create date object
  mutate(daily_average = rowMeans(select(., h1:h24))) %>% # transforming hourly data into daily data
  select(-h1:-h24) %>% # dropping hourly columns
  select(-meter_id)  ## drop meter ID

# interpolating N/A values with na.approx
load_clean$daily_average <- na.approx(load_clean$daily_average)

# check for missing dates by creating dummy data frame for dates
Days <- as.data.frame(seq.Date(from=as.Date("2005/01/01"),to=as.Date("2011/06/30"), by ="day"))
colnames(Days) <- "date"

#merge with the data with missing rows
date_check <-left_join(Days, load_clean, by="date")

# checking N/As
check_na <- is.na(date_check)
colSums(check_na) 


# cleaning data in pipe
humidity_clean <- humidity_RAW %>%
  mutate(date = ymd(date)) %>% ## create date object
  mutate(hourly_average = rowMeans(select(., rh_ws1:rh_ws28))) %>% #1 col per hour
  select(-rh_ws1:-rh_ws28) %>%  # dropping multiple obs
  mutate(hourly_average= na.approx(hourly_average)) %>% 
  pivot_wider(id_cols=date,
              names_from = hr,
              values_from = hourly_average,
              names_prefix = "h") %>% 
  mutate(daily_average = rowMeans(select(., h1:h24))) %>%# daily avg
  mutate(daily_average= na.approx(daily_average)) %>% 
  select(-h1:-h24) 

check_na <- is.na(humidity_clean)
colSums(check_na) 

```

```{r Cleaning}
load_clean_train <- load_clean %>% 
  filter(date<"2011-06-01")

load_clean_test <- load_clean %>% 
  filter(date >="2011-06-01")

```

```{r TS Objects}
load_ts <- ts(load_clean$daily_average, start = c(2005, 1), frequency = 365)
plot(load_ts)

train_ts <- ts(load_clean_train$daily_average, start = c(2005, 1), frequency = 365)
plot(train_ts)

test_ts <- ts(load_clean_test$daily_average, start = c(2011, 6), frequency = 365)
plot(test_ts)
```

```{r Initial plots}
#Plot of TS data
TS_Plot <- 
  ggplot(load_clean, aes(x=date, y=daily_average)) +
      geom_line()
plot(TS_Plot)

#ACF and PACF plots
par(mfrow=c(1,2))
ACF_Plot <- Acf(load_clean$daily_average, lag = 40, plot = TRUE)
PACF_Plot <- Pacf(load_clean$daily_average, lag = 40)
par(mfrow=c(1,1))

```
The initial plots show an weak exponential decay on the ACF and a strong correlation at lag 1 on the PACF. The TS plot shows at least two strong seasonal components; with seasonality within the years as well as seasonality within the months due to regular sinusoidal oscillations. 

```{r Decomposition}
#Using R decompose function
decompose_load <- decompose(load_ts,"additive")
plot(decompose_load)

#The ACF plot show a slow decay which is a sign of non-stationarity.

#Creating non-seasonal residential price time series because some models can't handle seasonality
deseasonal_load <- seasadj(decompose_load)  


#Using R decompose function
#decompose_test <- decompose(test_ts,"additive")
#plot(decompose_test)

#The ACF plot show a slow decay which is a sign of non-stationarity.

#Creating non-seasonal residential price time series because some models can't handle seasonality
#deseasonal_test <- seasadj(decompose_test)  

#Using R decompose function
decompose_train <- decompose(train_ts,"additive")
decompose_test <- decompose(test_ts,"additive")
plot(decompose_train)

#The ACF plot show a slow decay which is a sign of non-stationarity.

#Creating non-seasonal residential price time series because some models can't handle seasonality
deseasonal_train <- seasadj(decompose_train)  
deseasonal_test <- seasadj(decompose_test)  

```

## Forecasting with Naive methods

```{r Model 1: Arithmetic mean on training data}
#Model 1: Arithmetic mean on training data
Model1 <- meanf(train_ts,h=30)
summary(Model1)
plot(Model1)

# Forecast using Model1 on training
forecasted_Model1 <- forecast(Model1, h = 30)

# Extract the forecasted values from training
forecast_values_Model1 <- as.numeric(forecasted_Model1$mean)

# Extract the actual values from the testing data
actual_values_Model1 <- as.numeric(test_ts)

# Compare the forecasted training values with the actual values
comparison_Model1 <- data.frame(Actual = actual_values_Model1, Forecasted = forecast_values_Model1)

#Model 1: Arithmetic mean on original data
Model1_full <- meanf(load_ts,h=30)
summary(Model1_full)
#plot(Model1_full)

# Forecast using Model1
forecasted_Model1_full <- forecast(Model1_full, h = 30)

# Extract the forecasted values
forecast_values_Model1_full <- as.numeric(forecasted_Model1_full$mean)

print(forecast_values_Model1_full)

```

```{r Model 2: Arithmetic mean on deseasonalized data}
# Model 2: Arithmetic mean on deseasonalized data
Model2 <- meanf(deseasonal_train, h = 30)
summary(Model2)
plot(Model2)

# Forecast using Model2 on training
forecasted_Model2 <- forecast(Model2, h = 30)

# Extract the forecasted values from training
forecast_values_Model2 <- as.numeric(forecasted_Model2$mean)

# Extract the actual values from the testing data
actual_values_Model2 <- as.numeric(test_ts)
#could not decompose the testing data since it had less than two periods, so just using testing regular

# Compare the forecasted training values with the actual values
comparison_Model2 <- data.frame(Actual = actual_values_Model2, Forecasted = forecast_values_Model2)

# Forecast using Model2
forecasted_Model2_full <- forecast(Model2_full, h = 31)

# Extract the forecasted values
forecast_values_Model2_full <- as.numeric(forecasted_Model2_full$mean)

print(forecast_values_Model2_full)
```

```{r Model 3: Arithmetic mean on original data}

#Model 3: Arithmetic mean on original data
Model3_full <- meanf(train_ts,h=31)
summary(Model3_full)

#plot(Model3_full)
# Forecast using Model3 on training
forecasted_Model3 <- forecast(Model3, h = 30)

# Extract the forecasted values from training
forecast_values_Model3 <- as.numeric(forecasted_Model3$mean)

# Extract the actual values from the testing data
actual_values_Model3 <- as.numeric(test_ts)

# Compare the forecasted training values with the actual values
comparison_Model3 <- data.frame(Actual = actual_values_Model3, Forecasted = forecast_values_Model3)

#Model 3: Arithmetic mean on original data
Model3_full <- meanf(load_ts,h=31)
summary(Model3_full)
#plot(Model3_full)

# Forecast using Model3
forecasted_Model3_full <- forecast(Model3_full, h = 31)

# Extract the forecasted values
forecast_values_Model3_full <- as.numeric(forecasted_Model3_full$mean)

print(forecast_values_Model3_full)

```

```{r Model 4: Naive on deseasonalized data}
# Model 4: Naive on deseasonalized data
Model4 <- naive(deseasonal_train, h = 31)
summary(Model4)
plot(Model4)

# Forecast using Model4 on training
forecasted_Model4 <- forecast(Model4, h = 31)

# Extract the forecasted values from training
forecast_values_Model4 <- as.numeric(forecasted_Model4$mean)

# Compare the forecasted training values with the actual values
comparison_Model4 <- data.frame(Actual = actual_values_Model4, Forecasted = forecast_values_Model4)

# Forecast using Model4
forecasted_Model4_full <- forecast(deseasonal_load, h = 31)

# Extract the forecasted values
forecast_values_Model4_full <- as.numeric(forecasted_Model4_full$mean)

print(forecast_values_Model4_full)
```

## Forecasting with Simple Averaging Models

The simple averaging techniques we will explore are the moving average and the exponential smoothing. The simple moving average can be obtained with function sma() from package `smooth`. The main arguments function sma() will take are:

**y** ts object containing data needed to be forecasted
**order** order of simple moving average. If you don't specify, R will find the best order for you
**h** forecasting horizon, i.e., how many steps ahead do you want to forecast
**holdout** If TRUE, the last **h** observations are taken from the end of the data. One reason to holdout some data is to check model performance. We will talk about that on M9.
**silent** if FALSE, no output will be generated
**level** Confidence level for prediction intervals


The simple exponential smoothing can be obtained with the ses() function also from package `forecast`. The main arguments function ses() will take are:

**y** ts object containing data needed to be forecasted
**alpha** the smoothing constant. If you don't specify, R will find the best alpha for you. 
**h** forecasting horizon, i.e., how many steps ahead do you want to forecast
**holdout** If TRUE, the last **h** observations are taken from the end of the data. One reason to holdout some data is to check model performance. We will talk about that on M9.
**silent** if FALSE, no output will be generated
**level** Confidence level for prediction intervals


We will try these models on the original dataset and the deaseason electricity price.

```{r Simple Average Forecasts Deseasonal SUBMITTED}
# Model 5: Simple moving average on deseasonal data
Model5 <- sma(deseasonal_load,h=30 ,holdout = TRUE)
#summary(Model5)
#autoplot(deseasonal_load,series="Deseasonal")+
#  autolayer(Model5$forecast,series="SMA")

# Forecast using Model5 on training
forecasted_Model5 <- forecast(Model5, h = 30)

# Extract the forecasted values from training
forecast_values_Model5 <- as.numeric(forecasted_Model5$mean)

# Extract the actual values from the testing data
actual_values_Model5 <- as.numeric(test_ts)

# Compare the forecasted training values with the actual values
#comparison_Model5 <- data.frame(Actual = actual_values_Model5, Forecasted = forecast_values_Model5)

# Forecast using Model5
forecasted_Model5_full <- forecast(deseasonal_load, h = 31)

# Extract the forecasted values
forecast_values_Model5_full <- as.numeric(forecasted_Model5_full$mean)

print(forecast_values_Model5_full)

```


```{r SUBMITTED SMA Seasonal}
# Model 6: Simple moving average on original data
Model6 <- sma(load_ts,h=30)
#summary(Model6)
#autoplot(load_ts,
#         series="Original")+
#  autolayer(Model6$forecast,series="SMA-Model6")

# Forecast using Model6 on training
forecasted_Model6 <- forecast(Model6, h = 30)

# Extract the forecasted values from training
forecast_values_Model6 <- as.numeric(forecasted_Model6$mean)

# Extract the actual values from the testing data
actual_values_Model6 <- as.numeric(test_ts)

# Forecast using Model6
forecasted_Model6_full <- forecast(load_ts, h = 31)

# Extract the forecasted values
forecast_values_Model6_full <- as.numeric(forecasted_Model6_full$mean)

print(forecast_values_Model6_full)
```

```{r}

# Model 7:  Simple exponential smoothing on deseasonal data
Model7 <- ses(deseasonal_load,h=30)
plot(Model7)
#autoplot(deseasonal_load,
#         series="Deseasonal")+
#  autolayer(Model7$??,series="ES-Model7")


# Model 8:  Simple exponential smoothing on original data
Model8 <- ses(ts_load,h=30)
plot(Model8)

autoplot(ts_load,
         series="Original")+
  autolayer(Model8$fitted,series="ES-Model8")


```


## Forecasting with ARIMA

When forecasting with ARIMA models, first you will need to fit the model with the auto.arima() function we studied on M6 and M7. Then you will need to use the forecast() function from package `forecast`. forecast() is a generic function for forecasting from time series or time series models. It takes two main arguments:

**object** 	a time series or time series model for which forecasts are required;
**h** forecasting horizon, i.e., how many steps ahead do you want to forecast.

```{r AUTO SARIMA Submission 6}

# Model 9:  SARIMA on original data
Model9 <- auto.arima(train_ts)

#Model9_for <- forecast(Model9,h=30)
#plot(Model9_for)

#autoplot(ts_load,
#         series="Original")+
#  autolayer(Model9$fitted,series="SARIMA")+
#  autolayer(Model9_for$mean,series="SARIMA_for")

# Forecast using Model9 on training
forecasted_Model9 <- forecast(Model9, h = 30)

# Extract the forecasted values from training
forecast_values_Model9 <- as.numeric(forecasted_Model9$mean)

# Extract the actual values from the testing data
actual_values_Model9 <- as.numeric(test_ts)

# Forecast using Model6
forecasted_Model9_full <- forecast(load_ts, h = 31)

# Extract the forecasted values
forecast_values_Model9_full <- as.numeric(forecasted_Model9_full$mean)

print(forecast_values_Model9_full)

```

```{r}
# Model 10:  ARIMA on deseasonal data
Model10 <- auto.arima(deseasonal_train, seasonal = FALSE)

Model10_for <- forecast(Model10,h=12)
#plot(Model10_for)

#autoplot(deseasonal_load,
#         series="Deseasonal")+
#  autolayer(Model10$fitted,series="ARIMA")+
#  autolayer(Model10_for$mean,series="ARIMA_for")

# Forecast using Model10 on training
forecasted_Model10 <- forecast(Model10, h = 30)

# Extract the forecasted values from training
forecast_values_Model10 <- as.numeric(forecasted_Model10$mean)


# Forecast using Model6
forecasted_Model10_full <- forecast(load_ts, h = 31)

# Extract the forecasted values
forecast_values_Model10_full <- as.numeric(forecasted_Model10_full$mean)

print(forecast_values_Model10_full)
```

Submissions 5, 6 and 7 all yielded the same results. We will need to incorporate exogenous variable if we will improve our model further.

## NEURAL NETWORKS 

```{r NNETAR, echo=TRUE, message=FALSE, warning=FALSE}
#You can play with the different values for p and P, you can also use xreg with Fourier term to model the multiple seasonality

# Assuming humidity_clean is a dataframe with a column named daily_average containing humidity values
humidity_matrix <- as.matrix(humidity_clean$daily_average)  # Extract and convert to matrix

# Fit the neural network model
NN_fit <- nnetar(load_ts, p = 1, P = 0, xreg = humidity_matrix)

# Make forecasts using the fitted model
NN_for <- forecast(NN_fit, h = 365, xreg = humidity_matrix)
```

